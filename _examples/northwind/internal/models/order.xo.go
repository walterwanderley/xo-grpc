package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Order represents a row from 'Orders'.
type Order struct {
	OrderID    sql.NullInt64 `json:"OrderID"`    // OrderID
	CustomerID sql.NullInt64 `json:"CustomerID"` // CustomerID
	EmployeeID sql.NullInt64 `json:"EmployeeID"` // EmployeeID
	OrderDate  *Time         `json:"OrderDate"`  // OrderDate
	ShipperID  sql.NullInt64 `json:"ShipperID"`  // ShipperID
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Order] exists in the database.
func (o *Order) Exists() bool {
	return o._exists
}

// Deleted returns true when the [Order] has been marked for deletion
// from the database.
func (o *Order) Deleted() bool {
	return o._deleted
}

// Insert inserts the [Order] to the database.
func (o *Order) Insert(ctx context.Context, db DB) error {
	switch {
	case o._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case o._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO Orders (` +
		`OrderID, CustomerID, EmployeeID, OrderDate, ShipperID` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)`
	// run
	logf(sqlstr, o.CustomerID, o.EmployeeID, o.OrderDate, o.ShipperID)
	res, err := db.ExecContext(ctx, sqlstr, o.OrderID, o.CustomerID, o.EmployeeID, o.OrderDate, o.ShipperID)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	o.OrderID = sql.NullInt64{Valid: true, Int64: id}
	// set exists
	o._exists = true
	return nil
}

// Update updates a [Order] in the database.
func (o *Order) Update(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case o._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE Orders SET ` +
		`CustomerID = $1, EmployeeID = $2, OrderDate = $3, ShipperID = $4 ` +
		`WHERE OrderID = $5`
	// run
	logf(sqlstr, o.CustomerID, o.EmployeeID, o.OrderDate, o.ShipperID, o.OrderID)
	if _, err := db.ExecContext(ctx, sqlstr, o.CustomerID, o.EmployeeID, o.OrderDate, o.ShipperID, o.OrderID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Order] to the database.
func (o *Order) Save(ctx context.Context, db DB) error {
	if o.Exists() {
		return o.Update(ctx, db)
	}
	return o.Insert(ctx, db)
}

// Upsert performs an upsert for [Order].
func (o *Order) Upsert(ctx context.Context, db DB) error {
	switch {
	case o._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO Orders (` +
		`OrderID, CustomerID, EmployeeID, OrderDate, ShipperID` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (OrderID) DO ` +
		`UPDATE SET ` +
		`CustomerID = EXCLUDED.CustomerID, EmployeeID = EXCLUDED.EmployeeID, OrderDate = EXCLUDED.OrderDate, ShipperID = EXCLUDED.ShipperID `
	// run
	logf(sqlstr, o.OrderID, o.CustomerID, o.EmployeeID, o.OrderDate, o.ShipperID)
	if _, err := db.ExecContext(ctx, sqlstr, o.OrderID, o.CustomerID, o.EmployeeID, o.OrderDate, o.ShipperID); err != nil {
		return logerror(err)
	}
	// set exists
	o._exists = true
	return nil
}

// Delete deletes the [Order] from the database.
func (o *Order) Delete(ctx context.Context, db DB) error {
	switch {
	case !o._exists: // doesn't exist
		return nil
	case o._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM Orders ` +
		`WHERE OrderID = $1`
	// run
	logf(sqlstr, o.OrderID)
	if _, err := db.ExecContext(ctx, sqlstr, o.OrderID); err != nil {
		return logerror(err)
	}
	// set deleted
	o._deleted = true
	return nil
}

// OrderByOrderID retrieves a row from 'Orders' as a [Order].
//
// Generated from index 'Orders_OrderID_pkey'.
func OrderByOrderID(ctx context.Context, db DB, orderID sql.NullInt64) (*Order, error) {
	// query
	const sqlstr = `SELECT ` +
		`OrderID, CustomerID, EmployeeID, OrderDate, ShipperID ` +
		`FROM Orders ` +
		`WHERE OrderID = $1`
	// run
	logf(sqlstr, orderID)
	o := Order{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, orderID).Scan(&o.OrderID, &o.CustomerID, &o.EmployeeID, &o.OrderDate, &o.ShipperID); err != nil {
		return nil, logerror(err)
	}
	return &o, nil
}

// Customer returns the Customer associated with the [Order]'s (CustomerID).
//
// Generated from foreign key 'Orders_CustomerID_fkey'.
func (o *Order) Customer(ctx context.Context, db DB) (*Customer, error) {
	return CustomerByCustomerID(ctx, db, o.CustomerID)
}

// Employee returns the Employee associated with the [Order]'s (EmployeeID).
//
// Generated from foreign key 'Orders_EmployeeID_fkey'.
func (o *Order) Employee(ctx context.Context, db DB) (*Employee, error) {
	return EmployeeByEmployeeID(ctx, db, o.EmployeeID)
}

// Shipper returns the Shipper associated with the [Order]'s (ShipperID).
//
// Generated from foreign key 'Orders_ShipperID_fkey'.
func (o *Order) Shipper(ctx context.Context, db DB) (*Shipper, error) {
	return ShipperByShipperID(ctx, db, o.ShipperID)
}
